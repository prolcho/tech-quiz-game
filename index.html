<!DOCTYPE html>
<html lang="ko">
<head>

<!-- 추가 -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">


  <audio id="sfx-correct" src="correct.wav" preload="auto"></audio>
<audio id="sfx-wrong" src="wrong.wav" preload="auto"></audio>
<audio id="sfx-next" src="next.wav" preload="auto"></audio>

  <meta charset="UTF-8">

  <title>타자 드롭 퀴즈++</title>

  <link href="https://fonts.googleapis.com/css2?family=Do+Hyeon&family=Orbitron:wght@500&display=swap" rel="stylesheet">


  <!-- Head에 추가 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/static/pretendard.css" />



  


  <style>


#modeSelector label { display:flex; align-items:center; gap:6px; cursor:pointer; }
#modeSelector input[type="radio"] { transform: translateY(1px); }
@supports (accent-color: auto) {
  #modeSelector input[type="radio"] { accent-color: #00ffe1; }
}


/* 기존 #modeSelector 스타일 전부 지우고 ↓ 이걸로 교체 */
/* ✅ 전역에 둡니다: position: fixed 제거 버전 */
#modeSelector{
  background: rgba(0,0,0,0.6);
  border-radius: 10px;
  padding: 6px 12px;
  display: flex;
  gap: 10px;
  font-size: 12px;
  font-family: 'Orbitron', sans-serif;
  color: #00ffe1;
}

/* ✅ 모바일에선 줄 바꿈 허용 */
@media (max-width:480px){
  #modeSelector{
    flex-wrap: wrap;
    gap: 6px;
    font-size: 0.9rem;
  }
}

body.compact-mode #topUI > div,
body.compact-mode #textInput,
body.compact-mode #questionBox,
body.compact-mode #explainBox,
body.compact-mode #modeSelector {
  font-size: 0.75rem !important;
  padding: 4px 6px !important;
}

body.compact-mode #textInput {
  font-size: 1rem !important;
  width: 80vw !important;
}

body.compact-mode #questionBox {
  font-size: 1.2rem !important;
}



@keyframes pulseGlow {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 10px rgba(179, 139, 255, 0.3);
  }
  50% {
    transform: scale(1.08);
    box-shadow: 0 0 20px rgba(179, 139, 255, 0.6);
  }
}




:root {
  --main-accent: #b38bff; /* 귀여운 보라빛 강조색 */
  --bg-dark: #0a0a0a;
  --bg-light: #1a1a1a;
  --text-bright: #fff;
}





   html, body {
  margin: 0;
  padding: 0;
  background: linear-gradient(180deg, #0a0a0a, #1a1a1a);
  overflow: hidden;
}
body {
  font-family: 'Pretendard', 'Orbitron', sans-serif;
}

    canvas { display: block; }

    #questionBox {
    display: none;
      position: absolute; top: 30px; width: 100%; text-align: center;
      color: #00ffe1; font-size: 2rem; z-index: 10; text-shadow: 0 0 5px #0ff;
    }

    #scoreBox {
      top: 10px; left: 20px;
      color: #ffffff; font-size: 1rem; z-index: 10;
    }

    #inputBox {
      position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
      z-index: 10;
    }

    #textInput {
  font-size: 1.5rem;
  padding: 0.5rem;
  width: 320px;
  border: 2px solid #00ffe1;
  border-radius: 8px;
  background: #000000;
  color: #00ffe1;
  text-align: center;
  transition: transform 0.1s ease, box-shadow 0.3s ease;
  caret-color: #ff0; /* ✅ 추가 */
}

#textInput::placeholder {
  color: #00ffe188;    /* ✅ 신규 블록 전체 추가 */
  font-style: italic;
}


#textInput:focus {
  outline: none;
  box-shadow: 0 0 12px #00ffe1, 0 0 30px #00ffe155; /* 기존보다 더 강하게 */
  background-color: #111; /* 살짝 밝게 */
}

    #textInput.shake {
      transform: translateX(-50%) scale(1.05) rotate(1deg);
      animation: shake 0.3s ease;
    }

    @keyframes shake {
      0% { transform: translateX(-50%) translateX(0px); }
      25% { transform: translateX(-50%) translateX(-5px); }
      50% { transform: translateX(-50%) translateX(5px); }
      75% { transform: translateX(-50%) translateX(-5px); }
      100% { transform: translateX(-50%) translateX(0px); }
    }

    #explainBox {
  position: absolute;
  bottom: 20px;
  width: 100%;
  text-align: center;
  color: #ff0;
  font-size: 1.2rem;
  display: none;
  background-color: rgba(255,255,255,0.05);
  padding: 10px;
  border-radius: 10px;
  border: 1px solid #888;  
  opacity: 0;
  transition: opacity 0.5s ease;
}
#explainBox.visible {
  opacity: 1;
}

#progressBox {
  position: absolute;
  top: 70px;
  width: 100%;
  display: flex;
  justify-content: center;
  gap: 10px;
  z-index: 10;
}
.progress-dot {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background-color: #333;
  border: 2px solid #00ffe1;
  transition: background-color 0.3s ease;
}
.progress-dot.active {
  background-color: #00ffe1;
}




#floatingTextContainer {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 999;
}
.floating-text {
  position: absolute;
  color: #ff0;
  font-size: 1.5rem;
  animation: floatUp 1s ease-out forwards;
}
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-50px); }
}

.fade-out {
  opacity: 0;
  transition: opacity 0.5s ease;
}

.fade-in {
  opacity: 1;
  transition: opacity 0.5s ease;
}

@keyframes zoomFadeIn {
  0% {
    transform: scale(0.95);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes zoomFadeOut {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  100% {
    transform: scale(1.05);
    opacity: 0;
  }
}

.fade-in {
  animation: zoomFadeIn 0.5s ease forwards;
}

.fade-out {
  animation: zoomFadeOut 0.5s ease forwards;
}

body::before {
  content: "";
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-image: radial-gradient(#00ffe1 0.5px, transparent 0.5px);
  background-size: 20px 20px;
  opacity: 0.03;
  z-index: 0;
  animation: gridMove 30s linear infinite;
}
@keyframes gridMove {
  from { background-position: 0 0; }
  to { background-position: 100px 100px; }
}



/* ✅ 보라 버튼 둘을 키보드/입력창 위로 띄우고 좌/우로 분리 */
#manualHintButton,
#restartCurrentBtn{
  position: fixed !important;
  z-index: 1003 !important;
  bottom: calc(env(safe-area-inset-bottom) + var(--kb) + 88px) !important;
}

#manualHintButton{ left: 12px !important; right: auto !important; }
#restartCurrentBtn{ right: 12px !important; left: auto !important; }


@media (max-width: 480px) {
  #textInput {
    width: 90vw;
    font-size: 1.2rem;
  }

  #questionBox {
    font-size: 1.4rem;
    top: 20px;
  }

  #explainBox {
    font-size: 1rem;
    padding: 8px;
  }

  #scoreBox, #failCountBox, #statusBox {
    font-size: 0.9rem;
  }







  #startScreen,
  #congratsScreen {
    font-size: 1.4rem;
    padding: 20px;
  }


}



#topUI {
  position: fixed;
  top: 10px;
  left: 10px;
  right: 10px;
  z-index: 999;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: flex-start;
  align-items: flex-start;
}

#topUI > div {
  background: rgba(0, 0, 0, 0.6);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 0.9rem;
  font-family: 'Orbitron', sans-serif;
  color: #00ffe1;
}


    /* UI 버튼 스타일 추가 예정 시 */


/* === Keyboard & Layout overrides (추가) === */
:root { --kb: 0px; --footerH: 56px; --hudH: 48px; }

html, body { height: 100dvh; -webkit-text-size-adjust: 100%; }
body { overflow: hidden; } /* 내부 컨테이너만 스크롤 */

.app { min-height: 100dvh; display: grid; grid-template-rows: 1fr; }

.hud-top{
    
  position: fixed; top: calc(env(safe-area-inset-top) + 6px);
  left: 50%; transform: translateX(-50%); z-index: 1001;
  display:flex; gap:8px; flex-wrap:wrap; max-width:min(720px,94vw);


  
}

/* 중앙 표시 영역 */
.stage{
  position: relative; height: 100dvh; overflow:auto;
  display:flex; align-items:center; justify-content:center;
  padding:
    calc(env(safe-area-inset-top) + var(--hudH) + 12px)
    16px
    calc(env(safe-area-inset-bottom) + var(--kb) + var(--footerH) + 12px);
}

/* 문자 타일 행 */
.quiz-row{
  display:flex; flex-wrap:wrap; justify-content:center; align-items:center;
  gap:8px 10px; max-width:min(720px,92vw);
}

/* 문자 타일: 애니/이동 전부 끄기 (덮어쓰기) */
.quiz-row .ch{
  display:inline-flex; justify-content:center; align-items:center;
  width: clamp(28px, 8vw, 44px); height: clamp(28px, 8vw, 44px);
  font-size: clamp(16px, 4.5vw, 22px); font-weight:600; letter-spacing:.02em;
  border-radius:10px; border:1px solid rgba(53,246,215,.25);
  box-shadow: 0 0 12px rgba(53,246,215,.35);
  background:#000; color:#35f6d7;
  /* ↓ 기존 효과를 강제로 무력화 */
  position: static !important;
  transform: none !important;
  animation: none !important;
  transition: none !important;
}

/* 입력창: absolute → fixed (덮어쓰기) */
#inputBox{
  position: fixed !important;
  left:50%;
  transform: translateX(-50%) translateY(calc(var(--kb) * -1));
  bottom: calc(env(safe-area-inset-bottom) + 10px);
  z-index: 1002;
}

/* 자동 줌 방지 */
input, textarea { font-size: 16px; }

/* HUD 안의 아이템은 고정 좌표를 없애서 겹침 방지 */
.hud-top > * { position: static !important; }


canvas { position: fixed; inset: 0; z-index: 0; }
.hud-top, #questionBox, #progressBox, #inputBox, #explainBox, #floatingTextContainer { z-index: 1002; }

/* === 고무줄 스크롤(흰 화면) 방지 기본 설정 === */
html, body {
  margin: 0;
  padding: 0;
  background: #0a0a0a;            /* 혹시 노출돼도 검정으로 보이게 */
  overscroll-behavior: none;       /* 최상단/최하단 끌어도 바깥으로 스크롤 안 새어 나감 */
}

/* 내부 스크롤 쓰는 컨테이너들은 체이닝(바깥으로 튀는 것) 막기 */
.stage {
  overscroll-behavior: contain;    /* 컨테이너 끝에서 더 끌어도 바깥(body)로 안 넘어감 */
  -webkit-overflow-scrolling: touch; /* iOS 관성 스크롤 유지 (부드러움) */
}

/* 전체 힌트 팝업도 스크롤은 하되 바깥으로는 안 새게 */
#fullHintPopup {
  overflow-y: auto;
  overscroll-behavior: contain;
}

/* 혹시 “팝업 열렸을 때 바디 스크롤 잠그기”가 필요하면 이 클래스 사용 */
body.lock-scroll {
  height: 100vh;
  overflow: hidden;
}


/* ===== 상단/하단 레이아웃 겹침 해결 ===== */
html, body {
  margin: 0;
  padding: 0;
  background: #0a0a0a;
  overscroll-behavior: none; /* 흰 화면 방지(당겨도 바깥 스크롤 안 튐) */
}

/* HUD 실제 높이를 반영해 질문/진행점이 HUD 아래에 오도록 */
#questionBox, #progressBox {
  position: fixed !important;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1002;
}
#questionBox {
  top: calc(env(safe-area-inset-top) + var(--hudH) + 6px) !important;
}
#progressBox {
  top: calc(env(safe-area-inset-top) + var(--hudH) + 56px) !important;
}

/* 해설 박스가 입력창/키보드와 겹치지 않게 하단 여유 */
#explainBox {
  position: fixed !important;
  left: 0; right: 0;
  bottom: calc(env(safe-area-inset-bottom) + var(--kb) + 72px) !important;
  z-index: 1002;
}

/* 내부 스크롤 쓰는 영역은 바깥으로 스크롤 체이닝 금지 */
.stage, #fullHintPopup {
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
}

/* 팝업 떠 있을 때 바디 스크롤 잠그고 싶으면 이 클래스 토글 */
body.lock-scroll { height: 100vh; overflow: hidden; }

/* ====== 타일 ‘팡!’ 사라짐 애니메이션 ====== */
.quiz-row .ch.pop {
  animation: popOut 280ms ease forwards;
}
@keyframes popOut {
  0%   { transform: scale(1);   opacity: 1; }
  60%  { transform: scale(1.25);}
  100% { transform: scale(0.6); opacity: 0; filter: blur(2px); }
}


/* === 힌트 전체보기: 위쪽 고정 시트 === */
#fullHintPopup{
  display:none;
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: calc(env(safe-area-inset-top) + var(--hudH) + 8px); /* HUD 바로 아래 */
  width: min(680px, 96vw);
  max-height: calc(100dvh - (env(safe-area-inset-top) + var(--hudH) + var(--footerH) + var(--kb) + 24px));
  overflow: auto;
  z-index: 1003;

  background: #111;
  border: 1px solid #00ffe1;
  border-radius: 12px;
  padding: 16px;
  color: #00ffe1;
  box-sizing: border-box;
}

#fullHintPopup h2{
  margin: 0 0 12px;
  text-align: center;
  font-family: 'Orbitron', sans-serif;
  font-size: 1.2rem;
}

#fullHintContent{ font-size: 1rem; line-height: 1.6; }

#fullHintPopup .hint-actions{
  margin-top: 12px;
  display: flex; justify-content: center;
}

#fullHintPopup .hint-actions button{
  background: rgba(255,255,255,0.06);
  border: 1px solid var(--main-accent);
  border-radius: 12px;
  color: var(--main-accent);
  font-family: 'Orbitron', sans-serif;
  font-size: 0.95rem;
  padding: 6px 12px;
  backdrop-filter: blur(4px);
  cursor: pointer;
}


#skipHint{
  position: fixed;
  right: 20px;
  top: calc(env(safe-area-inset-top) + var(--hudH) + 8px);
  z-index: 1002;
}

#skipHint #skipBtn{
  font-size: 0.9rem;
  color: #ddd;
  background: rgba(0,0,0,0.6);
  padding: 8px 12px;
  border-radius: 10px;
  border: 1px solid #00ffe1;
  font-family: 'Orbitron', sans-serif;
  -webkit-tap-highlight-color: transparent;
}



  </style>
</head>
<body>


<div class="app">
<div class="hud-top" id="hudTop">
  <div id="scoreBox">점수: 0</div>
  <div id="failCountBox">❌ Fail: 0</div>
  <button id="pauseBtn" onclick="togglePause()" style="
    background:#111; color:#00ffe1; border:1px solid #00ffe1;
    padding:6px 12px; border-radius:8px; font-size:.9rem;">
    ⏸ 일시정지
  </button>

  <!-- ✅ HUD 안으로 이동 -->
  <div id="modeSelector">
    <label><input type="radio" name="mode" value="strict"> Strict</label>
    <label><input type="radio" name="mode" value="normal" checked> Normal</label>
    <label><input type="radio" name="mode" value="fuzzy"> Fuzzy</label>
  </div>
</div>

  


  <main class="stage">
    <div id="quizRow" class="quiz-row"></div>
  </main>



<!-- ✅ 전체 힌트 보기 수동 버튼 -->
<div id="manualHintButton" style="
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 1000;
">
  <button onclick="openFullHintManually()" style="
background: rgba(255, 255, 255, 0.06);
  border: 1px solid var(--main-accent);
  border-radius: 12px;
  color: var(--main-accent);
  font-family: 'Orbitron', sans-serif;
  font-size: 0.95rem;
  padding: 6px 12px;
  transition: all 0.3s ease;
  backdrop-filter: blur(4px);
  cursor: pointer;
  ">💡 힌트 전체 열기</button>
</div>



<div id="restartCurrentBtn" style="
  position: fixed;
  bottom: 20px;
  left: 160px;
  z-index: 1000;
">
  <button onclick="restartCurrentQuestion()" style="
background: rgba(255, 255, 255, 0.06);
  border: 1px solid var(--main-accent);
  border-radius: 12px;
  color: var(--main-accent);
  font-family: 'Orbitron', sans-serif;
  font-size: 0.95rem;
  padding: 6px 12px;
  transition: all 0.3s ease;
  backdrop-filter: blur(4px);
  cursor: pointer;
  ">🔄 현재 문제 다시</button>
</div>














<!-- 기존 #skipHint 내용 삭제 후 교체 -->
<div id="skipHint">
  <button id="skipBtn" type="button">⏩ 다음 문제 (Shift+→)</button>
</div>





  <div id="questionBox"></div>
  <div id="progressBox"></div>
<div id="pauseNotice" style="display:none; position:absolute; top:50%; left:50%;
transform:translate(-50%,-50%); color:#fff; font-size:2rem; background:#111; 
padding:1rem 2rem; border:2px solid #00ffe1; z-index:20;">
⏸ 일시정지 중
</div>


<div id="statusBox" style="
  position: fixed;
  top: 10px;
  right: 20px;
  background: rgba(0,0,0,0.7);
  color: #00ffff;
  padding: 8px 16px;
  border-radius: 12px;
  font-family: 'Orbitron', sans-serif;
  font-size: 14px;
  z-index: 999;
">
  진행: 1 / ?
</div>





  <div id="inputBox">
    <input type="text" id="textInput" placeholder="여기에 키워드 입력 후 Enter" autocomplete="off" />
  </div>
  <div id="explainBox"><span id="hintCharacter">⚡전기신:</span> <span id="hintText"></span></div>

  <div id="floatingTextContainer"></div>

  <canvas id="canvas"></canvas>



<div id="congratsScreen" style="
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  color: #00ffcc;
  font-size: 2rem;
  font-family: 'Orbitron', sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 9999;
  text-align: center;
">
  🎉 모든 문제를 완료하셨습니다!<br><br>
  <button onclick="restartQuiz()" style="
background: rgba(255, 255, 255, 0.06);
  border: 1px solid var(--main-accent);
  border-radius: 12px;
  color: var(--main-accent);
  font-family: 'Orbitron', sans-serif;
  font-size: 0.95rem;
  padding: 6px 12px;
  transition: all 0.3s ease;
  backdrop-filter: blur(4px);
  cursor: pointer;
  ">다시 시작하기</button>
</div>


<div id="startScreen" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  color: #00ffe1;
  font-family: 'Orbitron', sans-serif;
  font-size: 1.8rem;
  z-index: 9999;
  text-align: center;
">
  🧠 <strong>타자 드롭 퀴즈++</strong><br><br>
  <span style="font-size: 1rem; color: #999">Enter 키 입력 혹은 터치하여 시작하세요</span>
  <button id="startBtn" style="
  margin-top: 20px;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid var(--main-accent);
  border-radius: 12px;
  color: var(--main-accent);
  font-family: 'Orbitron', sans-serif;
  font-size: 1.2rem;
  padding: 10px 20px;
  transition: all 0.3s ease;
  backdrop-filter: blur(4px);
  cursor: pointer;
animation: pulseGlow 2s infinite ease-in-out;


">
  ▶ 시작하기
</button>

</div>








  <script>


const STATIC_MODE = true;


function isMobile() {
  return /iPhone|Android/i.test(navigator.userAgent);
}

window.addEventListener('resize', () => {
  if (!isMobile()) return;

  const ratio = window.innerHeight / window.outerHeight;
  const isKeyboardUp = ratio < 0.75;

  if (isKeyboardUp) {
    document.body.classList.add('compact-mode');
  } else {
    document.body.classList.remove('compact-mode');
  }
});



document.getElementById('startBtn').addEventListener('click', startQuiz);




function restartCurrentQuestion() {
  // 현재 문제의 상태를 초기화
  failCount = 0;
  activeLetters = [];
  fallingLetters = [];
  particles = [];
  letterSpawnTimer = 0;
  isPaused = false;
  textInput.value = '';
  explainBox.style.display = 'none';
  explainBox.classList.remove('visible');
  document.getElementById('fullHintPopup').style.display = 'none';

  // 다시 불러오기
  loadQuestion();
  updateStatusBox();
  playSound("sfx-next"); // 효과음으로 구분
}








function closeFullHintPopup() {
  document.getElementById('fullHintPopup').style.display = 'none';
  failCount = 0; // 🔁 초기화
  updateFailCountUI(); // UI에도 반영
  explainBox.style.display = 'none'; // 해설창도 함께 숨기기
  explainBox.classList.remove('visible');
}







function openFullHintManually() {
  const fullHintBox = document.getElementById('fullHintPopup');
  const content = document.getElementById('fullHintContent');
  const currentQuiz = quizData[current];
  let html = `<strong>문제:</strong> ${currentQuiz.title}<br><br>`;
  html += `<strong>힌트:</strong> ${currentQuiz.hint}<br><br>`;
  html += `<strong>정답 목록:</strong><br><ul>`;
  currentQuiz.answers.forEach(ans => {
    html += `<li><strong>${ans.letter}</strong>: ${ans.text}</li>`;
  });
  html += `</ul><br><em style="color:#ccc;">※ 학습용으로 정답 전체를 보여드립니다.</em>`;
  content.innerHTML = html;
  fullHintBox.style.display = 'block';
}


function skipQuestion() {
  if (!isStarted || isPaused) return;

  if (current + 1 >= quizData.length) {
    document.getElementById('congratsScreen').style.display = 'flex';
    return;
  }

  current++;
  failCount = 0;
  updateFailCountUI();

  loadQuestion();
  updateStatusBox();
  playSound("sfx-next");

  textInput.value = '';
  explainBox.style.display = 'none';
  explainBox.classList.remove('visible');
}

// ✅ 전역에서 1회만 연결 (skipQuestion 정의 바로 아래 추천)
const skipBtn = document.getElementById('skipBtn');
if (skipBtn) skipBtn.addEventListener('click', skipQuestion);


function restartQuiz() {
   isStarted = true;  // 🔥 추가
  current = 0;
  score = 0;
  failCount = 0;
  document.getElementById('congratsScreen').style.display = 'none';
  shuffleArray(quizData); // 다시 섞고
  loadQuestion();
  updateProgressUI();
  updateStatusBox();
}




function updateStatusBox() {
  const statusBox = document.getElementById('statusBox');
  statusBox.textContent = `진행: ${current + 1} / ${quizData.length}`;
}




function togglePause() {
  isPaused = !isPaused;
  wasManuallyPaused = isPaused; // ✅ 일시정지 했는지 기억해둠

  const pauseBox = document.getElementById('pauseNotice');
  const pauseBtn = document.getElementById('pauseBtn');

  pauseBox.style.display = isPaused ? 'block' : 'none';
  pauseBtn.textContent = isPaused ? "▶ 재개" : "⏸ 일시정지";

 if (!isPaused && !STATIC_MODE) animate();

}



function updateProgressUI() {
  const box = document.getElementById('progressBox');
  box.innerHTML = ''; // 초기화
  const total = quizData[current].answers.length;
  const currentHits = total - activeLetters.length;
  for (let i = 0; i < total; i++) {
    const dot = document.createElement('div');
    dot.classList.add('progress-dot');
    if (i < currentHits) dot.classList.add('active');
    box.appendChild(dot);
  }
}


function showFloatingText(x, y, text = "+1점!") {
  const span = document.createElement("span");
  span.className = "floating-text";
  span.textContent = text;
  span.style.left = `${x}px`;
  span.style.top = `${y}px`;
  document.getElementById("floatingTextContainer").appendChild(span);
  setTimeout(() => span.remove(), 1000);
}
function playSound(id) {
  const sound = document.getElementById(id);
  if (sound) {
    sound.currentTime = 0;
    sound.play();
  }
}


    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});




    canvas.height = window.innerHeight;

    const questionBox = document.getElementById('questionBox');
    const scoreBox = document.getElementById('scoreBox');
    const textInput = document.getElementById('textInput');
    const explainBox = document.getElementById('explainBox');

    const quizData = [
{
  title: "1. 3상에서 단상으로 변환 결선",
  hint: "스변역리",
  answers: [
    {
      letter: "스",
      text: "스코트결선",
      aliases: ["스코트", "스코트 결선", "Scott 결선", "Scott connection"]
    },
    {
      letter: "변",
      text: "변형우드브리지결선",
      aliases: ["변형우드브리지", "우드브리지", "우드브리지 결선", "Woodbridge 결선"]
    },
    {
      letter: "역",
      text: "역V결선",
      aliases: ["역V", "역V 결선", "역브이결선", "역 브이 결선"]
    },
    {
      letter: "리",
      text: "리액터와 콘덴서에 의한 방법",
      aliases: ["리액터", "콘덴서", "리액터 콘덴서 방법", "리액터와 콘덴서", "리액터 콘덴서"]
    }
  ],
  explain: "3상을 단상으로 변환하는 대표적 방식은 스코트결선, 변형우드브리지결선, 역V결선, 그리고 리액터와 콘덴서에 의한 방법이 있다."
},


 {
  title: "1-1. 스코트결선의 특징",
  hint: "단스전교이중권통",
  answers: [
    {
      letter: "단",
      text: "단상변압기 2개를 T형으로 결선한 방식",
      aliases: ["단상변압기", "T형결선", "T형", "T형 결선"]
    },
    {
      letter: "스",
      text: "스코트결선 이용시 90도 위상차가 있는 단상전원 2개를 얻음",
      aliases: ["90도 위상차", "위상차 90도", "단상전원 2개"]
    },
    {
      letter: "전",
      text: "전압불평형 방지를 위해 사용",
      aliases: ["전압불평형", "전압불균형", "불평형 방지"]
    },
    {
      letter: "교",
      text: "교류전기철도 AT급전방식에 주로 사용",
      aliases: ["AT급전방식", "교류전기철도", "급전방식"]
    },
    {
      letter: "이",
      text: "이용률이 92.8%로 높은 편",
      aliases: ["이용률 92.8%", "이용률 높음", "효율 92.8%"]
    },
    {
      letter: "중",
      text: "중성점 접지 불가",
      aliases: ["중성점 없음", "중성점 접지 불가", "접지 불가"]
    },
    {
      letter: "권",
      text: "권선 임피던스 정합 불가",
      aliases: ["임피던스 정합 안됨", "권선 정합 불가", "임피던스 불일치"]
    },
    {
      letter: "통",
      text: "통신선 유도장애 발생",
      aliases: ["통신선 장애", "유도장애", "유도 전압"]
    }
  ],
  explain: "단상 2개 T형, 90도 위상차, 전압불평형 방지, AT급전방식 사용, 이용률 92.8%, 중성점 접지 불가, 임피던스 정합 불가, 유도장애 발생"
},{
  title: "1-2. 변형우드브리지결선의 특징",
  hint: "승스스전",
  answers: [
    {
      letter: "승",
      text: "승압용 단권변압기를 이용한 방식이다",
      aliases: ["승압용 단권변압기", "단권변압기", "승압용"]
    },
    {
      letter: "스",
      text: "스코트결선 변압기와 동일한 기능을 가지면서 1차측에 중성점 접지를 취하는 방식",
      aliases: ["스코트와 동일 기능", "1차측 중성점 접지", "중성점 접지"]
    },
    {
      letter: "스",
      text: "스코트결선의 결점을 보완한 방식",
      aliases: ["스코트결선 보완", "결점 보완", "보완 방식"]
    },
    {
      letter: "전",
      text: "전기철도 장애 방지용으로 사용한다(일본)",
      aliases: ["전기철도", "장애 방지", "일본 전철"]
    }
  ],
  explain: "변형우드브리지결선은 승압용 단권변압기를 사용하고, 스코트결선의 기능과 결점을 보완하며, 중성점 접지가 가능하고 일본 전기철도에서 장애 방지용으로 사용됩니다."
},{
  "title": "전력선에 의한 통신선 유도장해 대책",
  "hint": "이차연연지이차교고저직중연유잡루",
  "answers": [
    {
      "letter": "이",
      "text": "이격거리를 크게 한다",
      "aliases": ["이격거리 확보", "거리 벌리기", "이격"]
    },
    {
      "letter": "차",
      "text": "차폐선을 사이에 설치한다",
      "aliases": ["차폐선 설치", "차폐", "차폐선"]
    },
    {
      "letter": "연",
      "text": "연가한다 (전력선)",
      "aliases": ["연가", "연가 방식", "연가 전력선"]
    },
    {
      "letter": "연",
      "text": "연피케이블과 광케이블을 사용",
      "aliases": ["연피케이블", "광케이블", "차폐 케이블"]
    },
    {
      "letter": "지",
      "text": "지상고를 높인다",
      "aliases": ["지상고 증가", "높이 조절", "지상고"]
    },
    {
      "letter": "이",
      "text": "이격거리를 크게 한다 (반복)",
      "aliases": ["거리 이격", "이격거리", "거리 확보"]
    },
    {
      "letter": "차",
      "text": "차폐선을 설치한다 (반복)",
      "aliases": ["차폐", "차폐선", "보호선"]
    },
    {
      "letter": "교",
      "text": "교차된 경우 직각으로 설치한다",
      "aliases": ["직각 교차", "직각 설치", "교차 직각"]
    },
    {
      "letter": "고",
      "text": "고속도 차단방식을 채용한다",
      "aliases": ["고속 차단", "빠른 차단", "고속도"]
    },
    {
      "letter": "저",
      "text": "중성점 저감접지의 경우 저항값을 크게 하여 지락전류를 줄인다",
      "aliases": ["저감접지", "저항 증대", "지락전류 줄이기"]
    },
    {
      "letter": "직",
      "text": "중성점 직접접지의 경우 다중접지하여 기유도전압을 낮춘다",
      "aliases": ["직접접지", "다중접지", "기유도전압 저감"]
    },
    {
      "letter": "중",
      "text": "중계코일을 중간에 넣어 구간 분할한다 (통신선)",
      "aliases": ["중계코일", "구간분할", "중간 삽입"]
    },
    {
      "letter": "연",
      "text": "연피케이블 사용",
      "aliases": ["연피 케이블", "차폐형 케이블", "연피"]
    },
    {
      "letter": "유",
      "text": "유도전압 억제를 위해 통신선측에 우수한 피뢰기를 사용",
      "aliases": ["유도전압 억제", "피뢰기", "통신선 피뢰기"]
    },
    {
      "letter": "잡",
      "text": "잡음 저감을 위해 배류코일로 통신선 접지",
      "aliases": ["잡음 제거", "배류코일", "통신선 접지"]
    },
    {
      "letter": "루",
      "text": "루트를 변경하거나 광케이블을 사용",
      "aliases": ["루트 변경", "경로 변경", "광케이블"]
    }
  ],
  "explain": "전력선에 의한 통신선 유도장해는 거리, 차폐, 접지 구조, 케이블 종류, 접지 방식 등 다양한 요소에 따라 영향을 받으며, 이를 완화하기 위한 종합적 대책에는 이격 확보, 연가, 차폐선, 피뢰기 설치, 루트 변경 등이 포함된다. 특히 접지 방식에 따라 지락전류 유입 방식이 달라지고, 이에 따라 유도전압 저감 전략도 달라진다."
},{
  "title": "분기회로 차단기 정격 산정방법",
  "hint": "설기보전차도최병절",
  "answers": [
    {
      "letter": "설",
      "text": "전동기 설계전류",
      "aliases": ["설계전류", "전동기 전류", "기준전류"]
    },
    {
      "letter": "기",
      "text": "전전압 기동배율",
      "aliases": ["기동배율", "전압배율", "전기동 배율"]
    },
    {
      "letter": "보",
      "text": "보호장치의 기약 동작배율",
      "aliases": ["보호장치 배율", "기약배율", "보호 배율"]
    },
    {
      "letter": "전",
      "text": "전동기 기동 돌입전류",
      "aliases": ["기동 돌입전류", "돌입전류", "전동기 기동전류"]
    },
    {
      "letter": "차",
      "text": "차단기 순시 동작배율",
      "aliases": ["차단기 배율", "순시동작", "순시배율"]
    },
    {
      "letter": "도",
      "text": "도체 굵기",
      "aliases": ["도체굵기", "전선굵기", "도체 크기"]
    },
    {
      "letter": "최",
      "text": "최소 단락전류",
      "aliases": ["최소단락", "최소단락전류", "단락전류"]
    },
    {
      "letter": "병",
      "text": "병렬 도체수",
      "aliases": ["병렬도체", "병렬수", "도체 병렬"]
    },
    {
      "letter": "절",
      "text": "절연물 및 주위온도에 따른 상수",
      "aliases": ["절연 상수", "주위온도", "절연물 온도"]
    }
  ],
  "explain": "분기회로 차단기의 정격을 산정할 때는 전동기의 설계전류, 기동 특성, 보호장치의 동작 특성, 차단기의 순시동작 조건 등을 모두 고려해야 하며, 도체 굵기, 병렬 도체수, 절연 및 환경 조건 등도 함께 반영되어야 한다."
}












];


let isStarted = false;
let current = 0;
let activeLetters = [];
let fallingLetters = [];


  let score = 0;
  let letterSpawnTimer = 0;
  let lives = 3;
  let isPaused = false;
  let particles = [];
  let failCount = 0;

// ✅ 실패 횟수 표시 함수 (전역으로 이동)
function updateFailCountUI() {
  document.getElementById('failCountBox').textContent = `❌ Fail: ${failCount}`;
}



let matchMode = 'normal'; // 기본 모드

let wasManuallyPaused = false;


let animationFrameId = null;  // 🔥 애니메이션 ID 추적용




    
const LETTER_SPEED = 1.0; // ✅ 일정한 속도

class FallingLetter {
  constructor(id, letter, answer, x) {
    this.id = id;           // 추가됨
    this.letter = letter;
    this.answer = answer;
    this.x = x;
    this.y = -50;
    this.speed = LETTER_SPEED;
    this.marked = false;
  }

      update() { this.y += this.speed; }
      draw(ctx) {
  ctx.font = '36px Orbitron';
  ctx.fillStyle = '#00ffe1';
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 15;
  ctx.fillText(this.letter, this.x, this.y);
  ctx.shadowBlur = 0; // reset
}

    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dx = (Math.random() - 0.5) * 6;
        this.dy = (Math.random() - 0.5) * 6;
        this.life = 60;
        this.size = 5 + Math.random() * 5;
      }
      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.life--;
      }
      draw(ctx) {
        ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

function spawnLetter(letterObj) {
  const x = Math.random() * (canvas.width - 200) + 100;
  fallingLetters.push(new FallingLetter(letterObj.id, letterObj.letter, letterObj.answer, x));
}


    function explode(x, y) {
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y));
      }
    }

    function animate() {
  // 정적 모드이거나 일시정지면 루프 시작/유지 안 함
  if (isPaused || STATIC_MODE) return;

  // 캔버스 프레임 초기화
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ▼ 동적(떨어지는 글자) 처리 — 정적 모드에선 안 들어옴
  letterSpawnTimer++;
  if (letterSpawnTimer % 180 === 0) {
    const remaining = activeLetters.filter(a => !fallingLetters.find(l => l.id === a.id));
    if (remaining.length > 0) {
      spawnLetter(remaining[0]);
    }
  }

  for (let i = fallingLetters.length - 1; i >= 0; i--) {
    const l = fallingLetters[i];
    l.update();
    l.draw(ctx);
    if (l.y > canvas.height + 30 && !l.marked) {
      fallingLetters.splice(i, 1);
      score -= 1;
      scoreBox.textContent = `점수: ${score}`;
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.update();
    p.draw(ctx);
    if (p.life <= 0) particles.splice(i, 1);
  }

  animationFrameId = requestAnimationFrame(animate);
}


function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}



function loadQuestion() {
  const q = quizData[current];
  textInput.value = '';
  explainBox.style.display = 'none';
  document.getElementById('fullHintPopup').style.display = 'none'; // ✅ 팝업 초기화

  questionBox.textContent = q.title;
  questionBox.style.display = 'block';

  activeLetters = [...q.hint].map((char, i) => ({
    id: i,
    letter: char,
    answer: q.answers[i]
  }));

  letterSpawnTimer = 0;
  isPaused = false;
  failCount = 0;
  updateFailCountUI(); // ✅ 실패 횟수 UI 초기화
  updateProgressUI();  // ✅ 진행률도 업데이트

  if (!quizData || quizData.length === 0) return; // ✅ 이 부분도 안에 있어야

  // ▼ 정적 글자 렌더 (중요)
  renderChars(q.hint);
}





textInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') {

  const isInputFocused = (document.activeElement.id === 'textInput');
  const isStartScreen = document.getElementById('startScreen').style.display !== 'none';
  const isCongratsScreen = document.getElementById('congratsScreen').style.display === 'flex';


if ((isStartScreen || !isStarted) && e.key === 'Enter') {
  startQuiz();
  return;
}

  if (isCongratsScreen) return;

  if (!isInputFocused) {
    e.preventDefault();
    textInput.focus();
    textInput.select();
  }



     if (isStarted && activeLetters.length === 0 && fallingLetters.length === 0) {
      if (current + 1 >= quizData.length) {
        document.getElementById('congratsScreen').style.display = 'flex';
        return;
      }
      // 다음 문제로 이동
      current++;
      loadQuestion();
      updateStatusBox();
      textInput.value = '';
    }if (document.getElementById('congratsScreen').style.display === 'flex' && e.key === 'Enter') {
    restartQuiz();
    document.getElementById('startScreen').style.display = 'none';
      return;
    }





    // 🔹 이미 시작된 경우: 정답 체크 로직
    const input = textInput.value.trim();
    let matched = false;
    // ⬇ 정적 모드일 땐 떨어지는 글자 대신, 남은 글자(activeLetters)의 '현재 목표'와 비교
if (STATIC_MODE) {
  const next = activeLetters[0]; // 남아있는 첫 글자(현재 목표)
  if (next && isMatchingAnswer(input, next.answer)) {
    playSound("sfx-correct");
    score += 1;
    scoreBox.textContent = `점수: ${score}`;
    showFloatingText(canvas.width/2, canvas.height*0.6, "+1점!");

    // 목표 하나 제거
    activeLetters.shift();
    popAndRemoveFirstTile();
    updateProgressUI();

    // 문제 완료 시 다음 문제로
    if (activeLetters.length === 0) {
      setTimeout(() => {
        if (current + 1 >= quizData.length) {
          document.getElementById('congratsScreen').style.display = 'flex';
          return;
        }
        playSound("sfx-next");
        current++;
        loadQuestion();
        updateStatusBox();
      }, 150);
    }

    textInput.value = '';
    return; // ✅ 정적 모드 처리는 여기서 끝
  } else {
    // 오답 처리(기존과 동일한 효과)
    playSound("sfx-wrong");
    failCount++;
    updateFailCountUI();

    if (failCount === 5) {
      document.getElementById("hintText").textContent = quizData[current].explain;
      explainBox.classList.add('visible');
      explainBox.style.display = 'block';
    }
    if (failCount === 10) {
      const fullHintBox = document.getElementById('fullHintPopup');
      const content = document.getElementById('fullHintContent');
      const currentQuiz = quizData[current];
      let html = `<strong>문제:</strong> ${currentQuiz.title}<br><br>`;
      html += `<strong>힌트:</strong> ${currentQuiz.hint}<br><br>`;
      html += `<strong>정답 목록:</strong><br><ul>`;
      currentQuiz.answers.forEach(ans => {
        html += `<li><strong>${ans.letter}</strong>: ${ans.text}</li>`;
      });
      html += `</ul><br><em style="color:#ccc;">※ 학습용으로 정답 전체를 보여드립니다.</em>`;
      content.innerHTML = html;
      fullHintBox.style.display = 'block';
    }

    textInput.classList.add('shake');
    setTimeout(() => textInput.classList.remove('shake'), 300);
    textInput.value = '';
    return; // ✅ 정적 모드 분기 종료
  }
}

    for (let i = 0; i < fallingLetters.length; i++) {
      const l = fallingLetters[i];
      if (!l.marked && isMatchingAnswer(input, l.answer)) {
        playSound("sfx-correct");
        l.marked = true;
        explode(l.x, l.y);
        showFloatingText(l.x, l.y);
        score += 1;
        scoreBox.textContent = `점수: ${score}`;
        fallingLetters.splice(i, 1);
activeLetters = activeLetters.filter(a => a.id !== l.id);
popAndRemoveTileById(l.id);   // ← 이 줄 추가 (해당 타일 팡!)
        updateProgressUI();
        matched = true;
        break;
      }
    }

       if (matched) {
      setTimeout(() => {
      if (activeLetters.length === 0 && fallingLetters.length === 0) {
  if (current + 1 >= quizData.length || !quizData[current + 1]) {
    document.getElementById('congratsScreen').style.display = 'flex';
    return;
  }


  const box = document.getElementById('questionBox');
  box.classList.add('fade-out');
  setTimeout(() => {
    playSound("sfx-next");
    current++;
    loadQuestion();
    box.classList.remove('fade-out');
    box.classList.add('fade-in');
    setTimeout(() => box.classList.remove('fade-in'), 500);
  }, 500);
}
      }, 100);
    }
                  

if (!matched) {
  playSound("sfx-wrong");
  failCount++;
  updateFailCountUI(); // ✅ 여기 추가

  // 🎯 해설은 정확히 5번째 틀렸을 때만
  if (failCount === 5) {
    document.getElementById("hintText").textContent = quizData[current].explain;
    explainBox.classList.add('visible');
    explainBox.style.display = 'block';
  }

  // 🎯 전체 보기 팝업은 정확히 10번째 틀렸을 때만
  if (failCount === 10) {
    const fullHintBox = document.getElementById('fullHintPopup');
    const content = document.getElementById('fullHintContent');
    const currentQuiz = quizData[current];
    let html = `<strong>문제:</strong> ${currentQuiz.title}<br><br>`;
    html += `<strong>힌트:</strong> ${currentQuiz.hint}<br><br>`;
    html += `<strong>정답 목록:</strong><br><ul>`;
    currentQuiz.answers.forEach(ans => {
      html += `<li><strong>${ans.letter}</strong>: ${ans.text}</li>`;
    });
    html += `</ul><br><em style="color:#ccc;">※ 학습용으로 정답 전체를 보여드립니다.</em>`;
    content.innerHTML = html;
    fullHintBox.style.display = 'block';
  }

  setTimeout(() => textInput.classList.remove('shake'), 300);





          if (failCount >= 5) {
            document.getElementById("hintText").textContent = quizData[current].explain;
explainBox.classList.add('visible');
           explainBox.style.display = 'block';
          }
          textInput.classList.add('shake');
          setTimeout(() => textInput.classList.remove('shake'), 300);
        }
        textInput.value = '';
      }   
    });


function isMatchingAnswer(userInput, answerObj) {
  const normalize = str =>
    str.replace(/\s/g, '')
       .replace(/[^\w가-힣]/g, '')
       .toLowerCase();

  const input = normalize(userInput);
  const base = normalize(answerObj.text);
  const aliases = (answerObj.aliases || []).map(normalize);

  if (matchMode === 'strict') {
    return input === base || aliases.includes(input);
  }

  if (matchMode === 'normal') {
    const wordsMatch = (inputRaw, targetRaw) => {
      const tokenize = str => str.match(/[가-힣\w]+/g) || [];
      const inputWords = tokenize(inputRaw);
      const targetWords = tokenize(targetRaw);
      return targetWords.every(tw => inputWords.some(iw => iw.includes(tw)));
    };
    return input.includes(base)
        || aliases.some(a => input.includes(a))
        || wordsMatch(userInput, answerObj.text)
        || aliases.some(alias => wordsMatch(userInput, alias));
  }

  if (matchMode === 'fuzzy') {
    return getSimilarity(input, base) >= 0.8
        || aliases.some(alias => getSimilarity(input, alias) >= 0.8);
  }

  return false;
}


function getSimilarity(a, b) {
  const distance = levenshtein(a, b);
  return 1 - distance / Math.max(a.length, b.length);
}

function levenshtein(a, b) {
  const matrix = Array.from({ length: a.length + 1 }, () => []);
  for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
  for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      );
    }
  }
  return matrix[a.length][b.length];
}




shuffleArray(quizData);
textInput.focus();
document.getElementById('statusBox').textContent = '진행: - / -';

// ✅ 여기 아래에 바로 추가하세요
document.querySelectorAll('input[name="mode"]').forEach(radio => {
  radio.addEventListener('change', (e) => {
    matchMode = e.target.value;
    console.log(`✅ 정답 체크 모드 변경됨: ${matchMode}`);
  });
});



// ✅ 인트로 화면 클릭 시 textInput에 포커스
document.getElementById('startScreen').addEventListener('click', () => {
  textInput.focus();
});
// ✅ 완료 화면 숨김 초기화 (인트로에서 잠깐 보이는 것 방지)
document.getElementById('congratsScreen').style.display = 'none';


document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const fullHintBox = document.getElementById('fullHintPopup');

    if (fullHintBox.style.display === 'block') {
      closeFullHintPopup(); // ✅ 이걸로 교체
    } else {
      openFullHintManually();
    }
  }






  
  // ✅ Shift + →로 문제 스킵
  if (e.shiftKey && e.key === 'ArrowRight') {
    if (!isStarted || isPaused) return;

    if (current + 1 >= quizData.length) {
      document.getElementById('congratsScreen').style.display = 'flex';
      return;
    }


    

    current++;
      failCount = 0; // ✅ 이 줄을 추가하세요!!!
updateFailCountUI(); // ✅ 초기화 시 UI 반영




    loadQuestion();
    updateStatusBox();
    playSound("sfx-next");

    // 효과적으로 다음 문제 넘어갈 수 있게 입력창 초기화
    textInput.value = '';
    explainBox.style.display = 'none';
    explainBox.classList.remove('visible');
    return;
  }

  // 기존 Enter 관련 포커스 복구
  if (e.key === 'Enter') {
    const isInputFocused = (document.activeElement.id === 'textInput');
    const isStartScreen = document.getElementById('startScreen').style.display !== 'none';
    const isCongratsScreen = document.getElementById('congratsScreen').style.display === 'flex';

    if (isStartScreen || isCongratsScreen) return;

    if (!isInputFocused) {
      e.preventDefault();
      textInput.focus();
      textInput.select();  // 텍스트 전체 선택 (UX 향상)
    }
  }
});


document.addEventListener("visibilitychange", function () {
  if (document.hidden) {
    cancelAnimationFrame(animationFrameId); // ✅ 루프 중지
  } else {
    // 수동 일시정지 중이 아니고, 게임이 시작된 상태면 재개
   if (!wasManuallyPaused && isStarted && !STATIC_MODE) {
  animate();
}

  }
});




function startQuiz() {
  if (isStarted) return;
  isStarted = true;
  document.getElementById('startScreen').style.display = 'none';
  questionBox.style.display = 'block';
  loadQuestion();
 updateStatusBox();
if (!STATIC_MODE) animate();  // 정적 모드면 루프 미호출

  setTimeout(() => {
    textInput.focus();
    textInput.select();
  }, 0);
}




// 모바일 터치 또는 클릭으로 시작
const startScreen = document.getElementById('startScreen');




  </script>



<div id="fullHintPopup">
  <h2>💡 힌트 전체 보기</h2>
  <div id="fullHintContent"></div>
  <div class="hint-actions">
    <button id="fullHintCloseBtn" onclick="closeFullHintPopup()">닫기 ✖</button>
  </div>
</div>



<script>
// 키보드 높이 반영 (추가)
(function(){
  const vv = window.visualViewport;
  if(!vv) return;
  let raf=null;
  const update=()=>{
    raf=null;
    const kb=Math.max(0, window.innerHeight - (vv.height + vv.offsetTop));
    document.documentElement.style.setProperty('--kb', kb + 'px');
  };
  const on=()=>{ if(!raf) raf=requestAnimationFrame(update); };
  vv.addEventListener('resize', on);
  vv.addEventListener('scroll', on);
  window.addEventListener('orientationchange', ()=>setTimeout(update,300));
  update();
})();

// HUD/입력창 실제 높이를 CSS 변수로 반영 (추가)
(function(){
  const hud=document.getElementById('hudTop');
  const box=document.getElementById('inputBox');
  const setVars=()=>{
    if(hud) document.documentElement.style.setProperty('--hudH', (hud.offsetHeight||48)+'px');
    if(box) document.documentElement.style.setProperty('--footerH', (box.offsetHeight||56)+'px');
  };
  setVars();
  if(hud) new ResizeObserver(setVars).observe(hud);
  if(box) new ResizeObserver(setVars).observe(box);
  window.addEventListener('resize', ()=>setTimeout(setVars,100));
})();

// 포커스 가림 방지 (추가)
document.addEventListener('focusin', e=>{
  if(e.target.matches('input,textarea,[contenteditable="true"]')){
    setTimeout(()=>e.target.scrollIntoView({block:'center', inline:'nearest', behavior:'smooth'}),120);
  }
});

// (선택) 문자 정적 렌더 함수 (추가)
function renderChars(text){
  const row=document.getElementById('quizRow');
  if(!row) return;
  row.innerHTML='';
  [...text].forEach((c, idx)=>{
    const s=document.createElement('span');
    s.className='ch';
    s.textContent=c;
    s.dataset.id = idx;        // ← 나중에 어떤 글자인지 찾을 표식
    row.appendChild(s);
  });
}

function popAndRemoveTileById(id){
  const row = document.getElementById('quizRow');
  if(!row) return;
  const el = row.querySelector(`.ch[data-id="${id}"]`);
  if(!el) return;
  el.classList.add('pop');
  setTimeout(()=>el.remove(), 280);
}

function popAndRemoveFirstTile(){
  const row = document.getElementById('quizRow');
  if(!row) return;
  const el = row.querySelector('.ch');
  if(!el) return;
  el.classList.add('pop');
  setTimeout(()=>el.remove(), 280);
}
// 예시: renderChars('건축전기설비기술사');
</script>

<script>
  // 구형 iOS에서 overscroll-behavior가 불안하면 바깥 영역 터치 이동 자체를 막아준다.
  (function () {
    const ALLOW = ['#fullHintPopup', '.stage']; // 스크롤 허용할 영역

    document.addEventListener('touchmove', function (e) {
      const ok = ALLOW.some(sel => e.target.closest(sel));
      if (!ok) {
        e.preventDefault(); // 바깥 영역의 고무줄(흰 화면) 방지
      }
    }, { passive: false });

    // 팝업 열릴 때 바디 스크롤 잠그고 싶으면:
    // document.body.classList.add('lock-scroll');
    // 닫을 때:
    // document.body.classList.remove('lock-scroll');
  })();
</script>

<script>
/**
 * 빈 화면(비인터랙티브 영역) 탭 시 키보드 닫기
 * - 입력창(#inputBox), 전체힌트팝업(#fullHintPopup), HUD(.hud-top), 보조 버튼(#manualHintButton, #restartCurrentBtn)은 제외
 * - pointerdown으로 터치/마우스 모두 대응
 */
(function(){
  const EXCLUDE_SELECTORS = [
    '#inputBox',            // 입력창 영역
    '#fullHintPopup',       // 전체 힌트 팝업
    '.hud-top',             // 상단 HUD
    '#manualHintButton',    // 힌트 전체 열기 버튼 래퍼
    '#restartCurrentBtn',   // 현재 문제 다시 버튼 래퍼
    '#modeSelector',        // 모드 라디오
    '#skipHint',            // 다음 문제 버튼
    '#startScreen',         // 시작 화면
    '#congratsScreen'       // 완료 화면
  ];

  function isInsideExcluded(elem){
    return EXCLUDE_SELECTORS.some(sel => elem.closest(sel));
  }

  function dismissKeyboard(){
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) {
      ae.blur();
    }
  }

  // 스테이지/캔버스/바디 어디를 탭해도 동작하도록 바디에 설치
  document.body.addEventListener('pointerdown', function(e){
    // 인터랙티브 영역이면 무시
    if (isInsideExcluded(e.target)) return;
    // 링크/버튼 등 기본 인터랙션 방해하지 않음
    dismissKeyboard();
  }, { passive: true });

  // iOS에서 종종 blur가 늦게 먹을 때를 대비한 보조 처리(선택)
  document.body.addEventListener('focusin', function(e){
    // 포커스가 다시 입력으로 옮겨졌다면 그대로 두기
  });
})();
</script>


</body>
</html>
